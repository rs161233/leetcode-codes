class Main {
    public static void main(String[] args) {
        String str="Java is funny coding language";
        String rev=reverse(str);
        System.out.println(rev);
    }   
        
    public static String reverse(String str){
        String rev="";
        
         for(int i=0; i<str.length();i++){
            rev=str.charAt(i)+rev;
        }
        return rev;
    }
    // public static String reverse(String str){
    //     StringBuilder rev= new StringBuilder();
        
    //      for (int i = str.length() - 1; i >= 0; i--) {
    //         rev.append(str.charAt(i));
    //     }
    //     return rev.toString();
    // }

/*
        ✅ Approach 2: Using StringBuilder's built-in reverse()
        return new StringBuilder(str).reverse().toString();
        */

        /*
        ✅ Approach 3: Using char[] array (in-place swap)
        char[] arr = str.toCharArray();
        int left = 0, right = arr.length - 1;
        while (left < right) {
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
        return new String(arr);
        */

        /*
        ✅ Approach 4: Using recursion (not efficient but asked in interviews)
        if (str == null || str.length() <= 1) return str;
        return reverse(str.substring(1)) + str.charAt(0);
        */

        /*
        ✅ Approach 5: Using Stack
        Stack<Character> stack = new Stack<>();
        for (char c : str.toCharArray()) {
            stack.push(c);
        }
        StringBuilder res = new StringBuilder();
        while (!stack.isEmpty()) {
            res.append(stack.pop());
        }
        return res.toString();
        */

        /*
        ✅ Approach 6: Using Java 8 Streams (fancy, not efficient)
        return str.chars()
                  .mapToObj(c -> (char)c)
                  .reduce("", (s, c) -> c + s, (s1, s2) -> s2 + s1);
        */
}
